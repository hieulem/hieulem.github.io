<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Publications — Search</title>
  <link rel="stylesheet" href="/files/jemdoc.css" />
  <link href="https://unpkg.com/vis-network/styles/vis-network.min.css" rel="stylesheet" />
  <style>
    body{font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;max-width:980px;margin:24px auto;color:#222}
    h1{margin-bottom:8px}
    .controls{display:flex;gap:12px;align-items:center;margin-bottom:14px}
    input[type=search]{flex:1;padding:8px 10px;border-radius:8px;border:1px solid #d0d7de}
    .btn{padding:8px 10px;border-radius:8px;border:1px solid #d0d7de;background:#fff;cursor:pointer}
    .results{margin-top:8px}
    .item{display:flex;gap:12px;padding:8px 6px;border-bottom:1px solid rgba(0,0,0,0.06)}
    .item .thumb{width:72px;height:72px;flex-shrink:0}
    .item .thumb img{width:100%;height:100%;object-fit:cover;border-radius:6px}
    .item .meta{flex:1;min-width:0}
    .title{font-weight:600;margin:0 0 6px 0}
    .authors{color:#6b7280;margin:0 0 6px 0;font-size:0.95rem}
    .venue{color:#006699;font-weight:600;margin-right:8px}
    .links{margin-top:6px}
    .hl{background:yellow}
  .kw-badge{display:inline-block;padding:6px 8px;border-radius:999px;border:1px solid #d0d7de;background:#fff;margin:4px 6px 4px 0;cursor:pointer;font-size:0.95rem}
  .kw-badge.small{padding:4px 6px;font-size:0.82rem;border-radius:6px}
  .kw-badge.active{background:#0366d6;color:#fff;border-color:transparent}
    .summary{margin-left:8px;padding:6px 8px;border-radius:6px;border:1px solid #d0d7de;background:#f7fbff;cursor:pointer}
    .note{color:#6b7280;font-size:0.95rem;margin-top:6px}
    .empty{padding:24px;text-align:center;color:#666}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
</head>
<body>
  <h1>Search Publications</h1>
  <div class="controls">
    <input id="q" type="search" placeholder="Search by keyword, author, venue..." aria-label="Search publications">
    <button id="clear" class="btn">Clear</button>
  </div>

  <div id="info" class="note">Loading publications…</div>

  <!-- Keywords summary / filter -->
  <div id="keywords" class="keywords" aria-label="Keyword filters" style="margin:10px 0"></div>

  <!-- Summarize / Influence graph -->
  <div id="summary-area" style="margin:12px 0">
    <div style="display:flex;gap:8px;align-items:center">
      <button id="summarize-graph" class="btn">Summarize (graph)</button>
      <label style="font-size:0.9rem">Min shared keywords:
        <input id="min-shared" type="number" value="1" min="1" max="3" style="width:56px;margin-left:6px;padding:4px;border-radius:6px;border:1px solid #d0d7de">
      </label>
      
    </div>
  <div id="graph" style="height:520px;min-height:420px;margin-top:8px;border:1px solid #e6e6e6;border-radius:8px;display:none;overflow:hidden"></div>
    <div id="graph-summary" class="note" style="margin-top:8px"></div>
    <div id="graph-legend" style="margin-top:8px;display:flex;flex-wrap:wrap;gap:8px;align-items:center"></div>
  </div>

  <div id="results" class="results" role="list"></div>

  <!-- Right-side detail panel for node info -->
  <aside id="detail-panel" style="position:fixed;right:18px;top:100px;width:320px;border-left:1px solid #e6e6e6;padding:12px;background:#fff;box-shadow:0 6px 18px rgba(0,0,0,0.04);border-radius:8px;display:none;z-index:60">
    <button id="detail-close" class="btn" style="float:right;padding:4px 8px">Close</button>
    <div id="detail-content" style="margin-top:6px"></div>
  </aside>

  <script>
  // Utility: try multiple paths for publications.yaml
  async function fetchPublications(){
    const paths = ['/publications.yaml','../publications.yaml','../../publications.yaml','publications.yaml'];
    let lastErr = null;
    for(const p of paths){
      try{
        const res = await fetch(p);
        if(!res.ok) { lastErr = new Error(res.status + ' ' + res.statusText); continue; }
        const text = await res.text();
        const data = jsyaml.load(text) || [];
        return data;
      }catch(e){ lastErr = e; }
    }
    throw lastErr || new Error('Could not fetch publications.yaml');
  }

  function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  function highlight(text, tokens){
    if(!text) return '';
    let out = escapeHtml(text);
    tokens.forEach(t => {
      if(!t) return;
      const re = new RegExp('('+t.replace(/[.*+?^${}()|[\]\\]/g,'\\$&') +')','ig');
      out = out.replace(re, '<mark class="hl">$1</mark>');
    });
    return out;
  }

  (async function(){
    const info = document.getElementById('info');
    const results = document.getElementById('results');
    const kwContainer = document.getElementById('keywords');

          
    try{
      const pubs = await fetchPublications();
      info.textContent = `Loaded ${pubs.length} publications`;

      // prepare searchable text for each pub
      const index = pubs.map(p => ({
        raw:p,
        text: [p.title||'', (Array.isArray(p.authors)?p.authors.join(' '):p.authors||''), p.venue||'', p.notes? (Array.isArray(p.notes)?p.notes.join(' '):p.notes):'', p.tldr||''].join(' | ').toLowerCase()
      }));

      // selectedKeyword: currently active keyword for filtering (null = none)
      let selectedKeyword = null;

      function renderKeywords(counts){
        // counts: Map keyword -> count
        kwContainer.innerHTML = '';
        // sort by count desc then alphabetically
        const entries = Object.entries(counts).sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0]));
        entries.forEach(([kw,cnt]) => {
          const b = document.createElement('button');
          b.className = 'kw-badge';
          b.type = 'button';
          b.textContent = kw + ' (' + cnt + ')';
          b.dataset.kw = kw;
          if(selectedKeyword === kw) b.classList.add('active');
          b.addEventListener('click', ()=>{
            selectedKeyword = (selectedKeyword === kw) ? null : kw;
            // update active classes
            Array.from(kwContainer.querySelectorAll('.kw-badge')).forEach(x=> x.classList.toggle('active', x.dataset.kw === selectedKeyword));
            // re-run search with same tokens
            const v = q.value.trim().toLowerCase();
            const tokens = v ? v.split(/\s+/).filter(Boolean) : [];
            const out = index.filter(it => tokens.every(tok => it.text.indexOf(tok) !== -1) && (!selectedKeyword || (it.raw.keywords||[]).includes(selectedKeyword)));
            renderList(out, tokens);
            info.textContent = `Showing ${out.length} of ${pubs.length} publications`;
          });
          kwContainer.appendChild(b);
        });
      }

      function computeKeywordCounts(){
        const counts = {};
        pubs.forEach(p => {
          const kws = p.keywords || [];
          kws.forEach(k => { counts[k] = (counts[k]||0) + 1; });
        });
        return counts;
      }

      function renderList(items, tokens){
        results.innerHTML = '';
        if(items.length===0){ results.innerHTML = '<div class="empty">No results</div>'; return; }
        items.forEach(it => {
          const p = it.raw;
          const item = document.createElement('div'); item.className='item';
            // expose any explicit method-name from the YAML on the DOM element for later use
            if(p && (p['method-name'] || p['method_name'])){
              item.dataset.methodName = p['method-name'] || p['method_name'];
            }
            // also store the title for reliable lookup when needed
            if(p && p.title) item.dataset.pubTitle = p.title;
          const thumb = document.createElement('div'); thumb.className='thumb';
          if(p.thumbnail){ 
            const im = document.createElement('img');
            // try multiple prefixes so thumbnails load from this subpage
            (function setThumb(imgEl, path){
              const candidates = [path, '../' + path, '../../' + path, '/' + path];
              let idx = 0;
              imgEl.onerror = () => {
                idx += 1;
                if (idx < candidates.length) imgEl.src = candidates[idx];
                else imgEl.style.display = 'none';
              };
              imgEl.src = candidates[0];
            })(im, p.thumbnail);
            thumb.appendChild(im);
          } 
          const meta = document.createElement('div'); meta.className='meta';
          const t = document.createElement('div'); t.className='title'; t.innerHTML = highlight(p.title||'', tokens);
          const a = document.createElement('div'); a.className='authors'; a.innerHTML = highlight(Array.isArray(p.authors)?p.authors.join(', '):(p.authors||''), tokens);
          const mv = document.createElement('div'); mv.innerHTML = (p.venue?('<span class="venue">'+escapeHtml(p.venue)+'</span> '):'') + (p.year?escapeHtml(p.year):'');
          const links = document.createElement('div'); links.className='links';
          if(p.links) {
            Object.entries(p.links).forEach(([label,url]) => {
              if(!url) return;
              const aEl = document.createElement('a'); aEl.href = url; aEl.target='_blank'; aEl.className='p-link'; aEl.textContent = label.charAt(0).toUpperCase()+label.slice(1);
              links.appendChild(aEl);
            });
          }
          // show keywords under links
          if(Array.isArray(p.keywords) && p.keywords.length){
            const kwline = document.createElement('div'); kwline.className='links'; kwline.style.marginTop='6px';
            p.keywords.forEach(k=>{
              const kb = document.createElement('button'); kb.type='button'; kb.className='kw-badge small'; kb.textContent = k; kb.dataset.kw = k;
              kb.addEventListener('click', ()=>{
                // simulate click on the main badge to filter
                const main = Array.from(kwContainer.querySelectorAll('.kw-badge')).find(x=> x.dataset.kw===k);
                if(main) main.click();
              });
              kwline.appendChild(kb);
            });
            meta.appendChild(kwline);
          }
          meta.appendChild(t); meta.appendChild(a); meta.appendChild(mv); meta.appendChild(links);
          item.appendChild(thumb); item.appendChild(meta);
          results.appendChild(item);
        });
      }

      // initial render all
  renderList(index, []);
  // compute and render keyword badges
  renderKeywords(computeKeywordCounts());

      // search
      const q = document.getElementById('q');
      let tmt = null;
      q.addEventListener('input', ()=>{
        clearTimeout(tmt); tmt = setTimeout(()=>{
          const v = q.value.trim().toLowerCase();
          if(!v){ renderList(index, []); info.textContent = `Loaded ${pubs.length} publications`; return; }
          const tokens = v.split(/\s+/).filter(Boolean);
          const out = index.filter(it => tokens.every(tok => it.text.indexOf(tok) !== -1));
          renderList(out, tokens);
          info.textContent = `Showing ${out.length} of ${pubs.length} publications`;
        },180);
      });

      document.getElementById('clear').addEventListener('click', ()=>{ q.value=''; q.dispatchEvent(new Event('input')); });

      // (removed stale summarize button listener that referenced a non-existent id)

      // Summarize (graph) button handler — builds an influence graph from shown results
      document.getElementById('summarize-graph').addEventListener('click', ()=>{
        const graphDiv = document.getElementById('graph');
        const gsum = document.getElementById('graph-summary');
        // collect currently rendered results
        const items = Array.from(results.querySelectorAll('.item'));
        if(items.length===0){ alert('No papers to summarize'); return; }

        // Build node per paper; edges when share keyword only
        const nodes = [];
        const edges = [];
        const titleToId = {};

        // color map for topics
        const topicColors = {
          '3d':'#1f77b4','medical':'#d62728','limited-data':'#2ca02c','efficient':'#ff7f0e','counting':'#9467bd',
          'implicit functions':'#8c564b','illumination':'#e377c2','uncertainty':'#7f7f7f','udf':'#bcbd22','sdf':'#17becf',
          'physics':'#aec7e8','segmentation':'#98df8a','generative-models':'#f7b6d2','controllable':'#ffbb78','diffusion':'#9edae5',
          'reliable':'#c7c7c7','token':'#6b6ecf'
        };

        function hexToRgb(hex){ const m = hex.replace('#',''); return [parseInt(m.substring(0,2),16), parseInt(m.substring(2,4),16), parseInt(m.substring(4,6),16)]; }
        function rgbToHex(rgb){ return '#'+rgb.map(v=> Math.max(0,Math.min(255,Math.round(v))).toString(16).padStart(2,'0')).join(''); }

        function mixColors(keys){
          // Prefer averaging mapped topic colors. If none of the provided keys
          // have a mapping in topicColors, return a visible fallback so edges
          // don't end up pale gray (which looks like 'no-color').
          const fallback = '#6b6ecf'; // visible purple-blue accent
          if(!keys || keys.length===0) return fallback;
          // collect only mapped colors
          const mapped = keys.map(k => topicColors[k] ? hexToRgb(topicColors[k]) : null).filter(Boolean);
          if(mapped.length === 0) return fallback;
          const avg = [0,0,0]; mapped.forEach(r=>{ avg[0]+=r[0]; avg[1]+=r[1]; avg[2]+=r[2]; });
          avg[0] = avg[0]/mapped.length; avg[1] = avg[1]/mapped.length; avg[2] = avg[2]/mapped.length;
          return rgbToHex(avg);
        }

        // helper to get arrays from meta
        function getKeywordsFromItem(el){ return Array.from(el.querySelectorAll('.kw-badge.small')).map(k=>k.textContent.trim().toLowerCase()) }

        // build short labels preferring a human-friendly short title
        const labelCounts = {};
        function shortLabelFromTitle(title){
          if(!title) return 'Paper';
          // common short forms: bracketed token (A+D Net), leading token before ':' or '-' etc
          let t = title.trim();
          // if title contains a short token like 'A+D Net' or 'PartSDF', prefer that
          const nameMatch = t.match(/^[A-Z][A-Za-z0-9+\-]{2,20}/);
          if(nameMatch) return nameMatch[0];
          // otherwise take first 3-4 words (remove stopwords)
          const stop = /^(the|a|an|of|for|via|with|and)$/i;
          const parts = t.split(/[\s:\-\(\)]+/).filter(s=> s && !stop.test(s));
          const take = parts.slice(0,3).join(' ');
          return take.length > 20 ? take.substring(0,20) + '...' : take;
        }

        items.forEach((it, idx) => {
          const fullTitle = it.querySelector('.title')?.textContent || ('paper-'+idx);
          titleToId[fullTitle] = idx+1;
          // prefer explicit method-name from YAML (attached to DOM), else generate from title
          const methodName = it.dataset && it.dataset.methodName ? it.dataset.methodName.trim() : null;
          const baseLabel = (methodName && methodName.length) ? methodName : shortLabelFromTitle(fullTitle).replace(/\s+/g,' ');
          labelCounts[baseLabel] = (labelCounts[baseLabel] || 0) + 1;
          const suffix = labelCounts[baseLabel] > 1 ? (' ' + String.fromCharCode(96 + labelCounts[baseLabel])) : '';
          const shortLabel = baseLabel + suffix;
          const kws = getKeywordsFromItem(it).filter(Boolean);
          // node visuals: keep nodes neutral/gray; edges will carry topic colors
          const nodeBg = '#f5f5f5';
          const nodeBorder = '#bdbdbd';
          nodes.push({id: idx+1, label: shortLabel, title: fullTitle, shape: 'box', color: {background: nodeBg, border: nodeBorder}, font: {multi: false, color: '#222'}});
        });

        // create edges only by shared keywords, applying min-shared threshold
        const minShared = Math.max(1, parseInt(document.getElementById('min-shared').value || '1',10));
        for(let i=0;i<items.length;i++){
          for(let j=i+1;j<items.length;j++){
            const k1 = getKeywordsFromItem(items[i]); const k2 = getKeywordsFromItem(items[j]);
            const sharedKey = k1.filter(x=> k2.includes(x));
            const weight = sharedKey.length;
            if(weight>=minShared){
              // color edge by the shared topics (blend if multiple)
              const edgeColor = mixColors(sharedKey);
              // width proportional to number of shared topics
              const width = Math.min(14, 2 + weight * 2);
              const edgeId = 'e:' + String(i+1) + '|' + String(j+1);
              edges.push({id: edgeId, from: i+1, to: j+1, value: weight, title: 'shared keywords: ' + sharedKey.join(', '), color: { color: edgeColor, opacity: 0.95 }, width: width, topics: sharedKey, baseColor: edgeColor});
            }
          }
        }

        // show graph div
        graphDiv.style.display = 'block';
  gsum.innerHTML = '<b>'+items.length+'</b> papers; <b>'+edges.length+'</b> connections (shared keywords only)';

        // render via vis-network
        const script = document.createElement('script'); script.src = 'https://unpkg.com/vis-network/standalone/umd/vis-network.min.js';
        script.onload = ()=>{
          const container = graphDiv;
          // create DataSets
          const nodesDS = new vis.DataSet(nodes);
          const edgesDS = new vis.DataSet(edges);
          // snapshot originals (after DataSet assigns ids) for reliable reset
          const originalNodes = nodesDS.get().map(n => JSON.parse(JSON.stringify(n)));
          const originalEdges = edgesDS.get().map(e => JSON.parse(JSON.stringify(e)));
          const origNodeMap = {}; originalNodes.forEach(n => { origNodeMap[n.id] = n; });
          const origEdgeMap = {}; originalEdges.forEach(e => { origEdgeMap[e.id] = e; });
          // temporary storage for edge state while hovering — stores the
          // immediate pre-hover edge state so blur can restore it exactly.
          const hoverEdgeBackup = {};
          const dataVis = { nodes: nodesDS, edges: edgesDS };
          // helper: robustly get topics for an edge id
          function getEdgeTopics(eid){
            const ed = edgesDS.get(eid) || origEdgeMap[eid] || {};
            if(ed.topics && ed.topics.length) return ed.topics;
            // try title parse: 'shared keywords: a, b'
            if(ed.title && typeof ed.title === 'string'){
              const m = ed.title.split(':');
              if(m.length>1) return m[1].split(',').map(s=>s.trim().toLowerCase()).filter(Boolean);
            }
            return [];
          }
          const options = {
            physics: { stabilization: true, barnesHut: { gravitationalConstant: -2000, springLength: 120, springConstant: 0.01 } },
            edges: { smooth: {type:'continuous'}, scaling: { min:1, max:12 }, color: {inherit:false, opacity:0.7} },
            nodes: { shape: 'box' , font: { multi: false, size: 14 }, scaling: { min:12, max:32 } },
            interaction: { hover: true, navigationButtons: true, tooltipDelay: 200 }
          };
          // clustering disabled
          // clear previous
          container.innerHTML = '';
          const network = new vis.Network(container, dataVis, options);
          // helper to clear highlights (restore original nodes/edges)
            function clearHighlight(){
              // restore visuals in-place to preserve node positions and avoid re-running physics
                // restore nodes
                nodesDS.forEach(n => {
                  const orig = origNodeMap[n.id];
                  const upd = { id: n.id };
                  if(orig && orig.color) upd.color = orig.color;
                  if(orig && orig.font) upd.font = orig.font;
                  if(orig && orig.size) upd.size = orig.size;
                  nodesDS.update(upd);
                });
                // restore edges
                edgesDS.forEach(e => {
                  const orig = origEdgeMap[e.id];
                  const upd = { id: e.id };
                  if(orig && orig.color) upd.color = orig.color;
                  if(orig && orig.width) upd.width = orig.width;
                  edgesDS.update(upd);
                });
              // restore legend active state
              Array.from(document.querySelectorAll('#graph-legend .legend-swatch')).forEach(s => s.classList.remove('active'));
            }

          // click handler: focus and highlight node and its keyword neighbors
          network.on('click', params => {
            const clicked = params.nodes && params.nodes.length ? params.nodes[0] : null;
            clearHighlight();
            // if click on background, reset highlighting
            if(!clicked){
              clearHighlight();
              return;
            }
            // clustering is disabled; clicked id will always be a paper node
            // focus (center) the clicked node
            try{ network.focus(clicked, { scale: 1.1, animation: { duration: 300 } }); }catch(e){}

            // get connected nodes via the network API
            const connectedNodeIds = network.getConnectedNodes(clicked) || [];
            // compute connected edges robustly from the DataSet (match from/to)
            const connectedEdgeIds = (edgesDS.get() || []).filter(ed => Number(ed.from) === Number(clicked) || Number(ed.to) === Number(clicked)).map(ed => String(ed.id));
            const connectedSet = new Set(connectedEdgeIds);

              // Fade non-connected edges and preserve connected edges' current visuals.
              // Normalize edge ids as strings for comparison.
              nodesDS.forEach(n => nodesDS.update({ id: n.id, color: { background: '#fafafa', border: '#efefef' }, font: { color: '#bbb' }, size: 12 }));
              edgesDS.forEach(e => {
                try{
                  const eid = String(e.id);
                  const isConnected = connectedSet.has(eid);
                  // preserve connected edges exactly as they currently are
                  if(isConnected){
                    // For connected edges, explicitly use the topic-derived/base color
                    // so we don't accidentally pick up transient hover colors.
                    const orig = origEdgeMap[eid] || edgesDS.get(eid) || e;
                    const topics = (orig && orig.topics && orig.topics.length) ? orig.topics : getEdgeTopics(eid);
                    const colorForEdge = (orig && orig.baseColor) ? orig.baseColor : (topics && topics.length ? mixColors(topics) : ((orig && orig.color && orig.color.color) ? orig.color.color : '#6b6ecf'));
                    const opacity = (orig && orig.color && (orig.color.opacity !== undefined)) ? orig.color.opacity : 0.95;
                    const value = (orig && orig.value) ? orig.value : ((edgesDS.get(eid) && edgesDS.get(eid).value) || 1);
                    const w = Math.min(14, 2 + (value||1) * 2);
                    edgesDS.update({ id: eid, color: { color: colorForEdge, opacity: opacity }, width: w });
                  }else{
                    // fade other edges: keep the same hue but reduce opacity and width
                    const curr = edgesDS.get(eid) || origEdgeMap[eid] || e;
                    const base = (curr && curr.color && curr.color.color) ? curr.color.color : ((curr && curr.baseColor) ? curr.baseColor : ((curr && curr.topics) ? mixColors(curr.topics) : '#ddd'));
                    edgesDS.update({ id: eid, color: { color: base, opacity: 0.12 }, width: 1 });
                  }
                }catch(_){ }
              });

            // emphasize clicked node and neighbor nodes only
            const selNode = nodesDS.get(clicked);
            const brightBg = (selNode && selNode.color && selNode.color.background) ? selNode.color.background : '#ffffff';
            nodesDS.update({ id: clicked, color: { background: brightBg, border: '#000' }, font: { color: '#000', size: 18, face: 'Inter' }, size: 44 });
            connectedNodeIds.forEach(id => {
              const nd = nodesDS.get(id);
              nodesDS.update({ id: id, color: Object.assign({}, nd.color, { border: '#333' }), font: { color: '#111', size: 14 }, size: 22 });
            });
            // Do not recolor edges on click. If edges were changed by hover or
            // legend, use clearHighlight to fully restore originals (we already
            // called clearHighlight at the start of this handler).
          });

          // hover handlers: lightly emphasize nodes on hover only (no edge color changes)
          network.on('hoverNode', params => {
            const id = params.node;
            try{ nodesDS.update({ id: id, size: 26 }); }catch(_){ }
          });
          network.on('blurNode', params => {
            const id = params.node;
            const orig = origNodeMap[id];
            if(orig){ nodesDS.update({ id: id, size: orig.size || 18 }); }
          });

          // hoverEdge: backup the current edge state (so we can restore it on blur)
          // then apply a temporary highlight. blurEdge will restore the backed-up state.
          network.on('hoverEdge', params => {
            try{
              const id = String(params.edge);
              if(!id) return;
              // if we don't already have a backup for this hover, save the current state
              if(!hoverEdgeBackup[id]){
                const curr = edgesDS.get(id) || origEdgeMap[id] || {};
                // shallow clone the fields we care about
                hoverEdgeBackup[id] = { color: curr.color ? JSON.parse(JSON.stringify(curr.color)) : undefined, width: curr.width };
              }
              // apply a subtle temporary highlight: keep same color but boost opacity/width
              const currEdge = edgesDS.get(id) || origEdgeMap[id] || {};
              const currentColor = (currEdge && currEdge.color && currEdge.color.color) ? currEdge.color.color : (currEdge && currEdge.baseColor) ? currEdge.baseColor : (currEdge && currEdge.topics ? mixColors(currEdge.topics) : '#6b6ecf');
              const newWidth = Math.min(24, (currEdge && currEdge.width ? currEdge.width : 2) + 3);
              edgesDS.update({ id: id, color: { color: currentColor, opacity: 1 }, width: newWidth });
            }catch(_){ }
          });

          network.on('blurEdge', params => {
            try{
              const id = String(params.edge);
              if(!id) return;
              const backup = hoverEdgeBackup[id];
              if(backup){
                edgesDS.update({ id: id, color: backup.color, width: backup.width });
                delete hoverEdgeBackup[id];
              } else {
                // fallback: restore from original snapshot if nothing in backup
                const orig = origEdgeMap[id];
                if(orig){ edgesDS.update({ id: id, color: orig.color, width: orig.width }); }
              }
            }catch(_){ }
          });

          

          // build dynamic legend of keywords present in this graph
          const legend = document.getElementById('graph-legend'); legend.innerHTML = '';
          // compute keyword counts
          const kwCounts = {};
          items.forEach((it, idx) => { const kws = getKeywordsFromItem(it); kws.forEach(k=>{ kwCounts[k] = (kwCounts[k]||0)+1 }); });
          // sort keywords by count desc
          const kwEntries = Object.entries(kwCounts).sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0]));
          kwEntries.forEach(([k,c]) => {
            const sw = document.createElement('button'); sw.type='button'; sw.className='legend-swatch'; sw.style.display='inline-flex'; sw.style.alignItems='center'; sw.style.gap='8px'; sw.style.padding='6px 8px'; sw.style.borderRadius='8px'; sw.style.border='1px solid #e6e6e6'; sw.style.cursor='pointer';
            const color = topicColors[k] || '#ddd';
            const box = document.createElement('span'); box.style.width='14px'; box.style.height='14px'; box.style.borderRadius='4px'; box.style.display='inline-block'; box.style.background=color; box.dataset.kw=k;
            const lab = document.createElement('span'); lab.textContent = k + ' ('+c+')'; lab.style.fontSize='0.9rem'; lab.style.color='#333';
            sw.appendChild(box); sw.appendChild(lab);
            // click highlights nodes with this keyword (toggle)
            sw.addEventListener('click', ()=>{
              const active = sw.classList.toggle('active');
              Array.from(document.querySelectorAll('#graph-legend .legend-swatch')).forEach(s=>{ if(s!==sw) s.classList.remove('active'); });
              if(!active){ clearHighlight(); return; }
              // dim nodes and fade non-matching edges while preserving base colors
              nodesDS.forEach(n => nodesDS.update({ id: n.id, color: { background: '#fafafa', border: '#efefef' }, font: { color: '#bbb' }, size: 12 }));
              edgesDS.forEach(e => {
                const orig = origEdgeMap[e.id] || e;
                const baseColor = (orig && orig.baseColor) ? orig.baseColor : ((orig && orig.color && orig.color.color) ? orig.color.color : ((orig && orig.topics) ? mixColors(orig.topics) : '#ddd'));
                edgesDS.update({ id: e.id, color: { color: baseColor, opacity: 0.12 }, width: 1 });
              });
              // find nodes that have this kw and emphasize them
              nodes.forEach(n => {
                const idx = n.id-1; const kws = getKeywordsFromItem(items[idx]);
                if(kws.includes(k)){
                  const nd = nodesDS.get(n.id);
                  nodesDS.update({ id: n.id, color: Object.assign({}, nd.color, { border: '#333' }), font: { color: '#111', size: 14 }, size: 20 });
                }
              });
            });
            legend.appendChild(sw);
          });
        };
        document.body.appendChild(script);
      });

    }catch(err){
      console.error(err);
      document.getElementById('info').textContent = 'Failed to load publications.yaml — please serve the site over HTTP or ensure the path is correct.';
      document.getElementById('results').innerHTML = '';
    }
  })();
  </script>
</body>
</html>
